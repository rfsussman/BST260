y = a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
if(b^2 == 4*a*c){
printout = paste0("There is one solution. The solution is ", (-b + sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red")
}else if(b^2 > 4*a*c){
printout = paste0("There are two solutions. The solutions are ", (-b + sqrt(b^2 - 4*a*c))/(2*a), " and ", (-b - sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red")
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red")
}else if(b^2 < 4*a*c){
printout = paste0("There are no real solutions.")
}
a = 1
b = -2
c = -5
if(b^2 == 4*a*c){
printout = paste0("There is one solution. The solution is ", (-b + sqrt(b^2 - 4*a*c))/(2*a), ".")
}else if(b^2 > 4*a*c){
printout = paste0("There are two solutions. The solutions are ", (-b + sqrt(b^2 - 4*a*c))/(2*a), " and ", (-b - sqrt(b^2 - 4*a*c))/(2*a), ".")
}else if(b^2 < 4*a*c){
printout = paste0("There are no real solutions.")
}
x = seq(-5, 5, length.out = 300)
y = a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
if(b^2 == 4*a*c){
printout = paste0("There is one solution. The solution is ", (-b + sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red")
}else if(b^2 > 4*a*c){
printout = paste0("There are two solutions. The solutions are ", (-b + sqrt(b^2 - 4*a*c))/(2*a), " and ", (-b - sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red")
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red")
}else if(b^2 < 4*a*c){
printout = paste0("There are no real solutions.")
}
```{r}
x = seq(-5, 5, length.out = 300)
y = a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
if(b^2 == 4*a*c){
printout = paste0("There is one solution. The solution is ", (-b + sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
}else if(b^2 > 4*a*c){
printout = paste0("There are two solutions. The solutions are ", (-b + sqrt(b^2 - 4*a*c))/(2*a), " and ", (-b - sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
}else if(b^2 < 4*a*c){
printout = paste0("There are no real solutions.")
}
x = seq(-5, 5, length.out = 300)
y = a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
if(b^2 == 4*a*c){
printout = paste0("There is one solution. The solution is ", (-b + sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
}else if(b^2 > 4*a*c){
printout = paste0("There are two solutions. The solutions are ", (-b + sqrt(b^2 - 4*a*c))/(2*a), " and ", (-b - sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
}else if(b^2 < 4*a*c){
printout = paste0("There are no real solutions.")
}
x = seq(-5, 5, length.out = 300)
y = a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
x = seq(-5, 5, length.out = 300)
y = a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
if(b^2 == 4*a*c){
printout = paste0("There is one solution. The solution is ", (-b + sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
}else if(b^2 > 4*a*c){
printout = paste0("There are two solutions. The solutions are ", (-b + sqrt(b^2 - 4*a*c))/(2*a), " and ", (-b - sqrt(b^2 - 4*a*c))/(2*a), ".")
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty = 2)
}else if(b^2 < 4*a*c){
printout = paste0("There are no real solutions.")
}
printout
---
title: "HW0"
rmarkdown::render("HW0.qmd", "pdf_document")
x=seq(-5, 5, length.out = 300)
y=a*x^2 + b*x + c
lines(x, y)
x=seq(-5, 5, length.out = 300)
y=a*x^2 + b*x + c
pltot(x, y)
x=seq(-5, 5, length.out = 300)
y=a*x^2 + b*x + c
plot(x, y)
abline(h = 0)
if(b^2 == 4*a*c){
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
}else if(b^2 > 4*a*c){
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
}
x=seq(-5, 5, length.out = 300)
y=a*x^2 + b*x + c
plot(x, y, type = "l")
abline(h = 0)
if(b^2 == 4*a*c){
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
}else if(b^2 > 4*a*c){
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
}
x=seq(-5, 5, length.out = 300)
plot(x, a*x^2 + b*x + c, type = "l")
abline(h = 0, lty = 2)
x=seq(-5, 5, length.out = 300)
plot(x, a*x^2 + b*x + c, type = "l")
abline(h = 0, lty = 2)
if(b^2 == 4*a*c){
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
}else if(b^2 > 4*a*c){
abline(v = (-b + sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
abline(v = (-b - sqrt(b^2 - 4*a*c))/(2*a), col = "red", lty=2)
}
args(log)
ls
ls(
)
?"<"
co2
t = co2
rm(list = ls())
# 1
n = 100
n*(n+1)/2
# 2
n = 1000
n*(n+1)/2
# 3
n <- 1000
x <- seq(1, n)
sum(x)
x
# 4
log(sqrt(100))
x= 5
log(10^5)
log(10)
log(e)
log(2.71)
log(exp(x))
exp(log(x, base = 2))
# 6
library(dslabs)
murders
m = murders
str(m)
murders = murders
str(murders)
# 7
names(murders)
# 8
a = murders$abb
class(a)
# 9
b = murders[, "abb"]
b
class(b)
# 10
identical(a, b)
# 10
class(murders$region)
length(levels(murders$region))
# 11
table(murders$region)
# 12
temp = c(35, 88, 42, 84, 81, 30)
?names
# 14
names(temp) = city
# 13
city = c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")
# 14
names(temp) = city
temp
# 15
city[1:3]
# 16
temp["Paris"]
# 16
temp[c("Paris", "San Juan")]
# 17
12:73
# 18
1:99:2
# 18
seq(1, 99, by = 2)
# 19
seq(6, 54, by = 4/7)
length(seq(6, 54, by = 4/7))
# 20
a <- seq(1, 10, 0.5)
class(a)
# 21
a <- seq(1, 10)
class(a)
# 22
class(1L)
as.integer(x)
# 23
x <- c("1", "3", "5")
as.integer(x)
# 24
pop = murders$population
pop = sort(pop)
pop
pop[1]
# 24
pop = murders$population
sort(pop)[1]
# 25
order(pop)
# 25
pop[order(pop) == 1]
order(pop) == 1
# 25
pop[order(pop) == 1]
# 25
order(pop) == 1
# 25
which(order(pop) == 1)
murders$population[29]
# 25
which.max(order(pop))
order(pop)
# 25
which.max(order(pop))
# 25
pop[which.max(order(pop))]
order(pop)
sort(pop)
order(pop)
# 25
which(order(pop) == 1)
pop[29]
pop
# 24
pop = murders$population
sort(pop)[1]
order(pop) == 1
sort(pop)
pop[order(pop) == 1]
pop[order(pop)]
# 25
pop[order(pop)][1]
# 26
pop[which.min(pop)]
# 27
states = murders$state
states[which.min(pop)]
# 28
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro",
"San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
rank(pop)
# 28
ranks = states[rank(pop)]
ranks
max(pop)
states[which.max(pop)]
rank(pop)
# 28
ranks = states[rank(pop)]
ranks
pop[rank(pop)]
?rank
rank(pop)
pop[rank(pop)]
pop[36]
pop[length(pop)]
rank(state)
rank(states)
rank(pop)
pop[rank(pop),]
idx = rank(pop)
pop[idx]
idx
pop[29]
order(pop, idx)
c(5, 2,3, 6,1 )
v = c(5, 2,3, 6,1 )
rank(v)
v[rank(v)]
v[sort(rank(v))]
v[order(rank(v))]
order(rank(pop))
pop[order(rank(pop))]
# 28
ranks = states[order(rank(pop))]
ranks
my_df = data.frame(states, ranks)
my_df
rank(pop)
my_df = data.frame(ranks, rank(pop))
my_df
# 28
ranks = states[order(rank(pop))]
ranks
order(rank(pop))
sort(Rank(pop))
sort(rank(pop))
my_df = data.frame(states, rank(pop))
my_df
sort(my_df$rank.pop.)
sort(my_df[my_df$rank.pop.])
view(my_df)
View(my_df)
order(rank(pop))
# 29
ind = sort(my_df$rank.pop., ascending = FALSE)
seq(1:50, by = -1)
seq(1,50, by = -1)
?seq
1:-1:5
5:-1:1
my_df$rank.pop.
# 29
ind = 51:-1:1
ind
my_df[ind, ]
my_df$rank.pop.
?sort
sort(my_df$rank.pop., descending = TRUE)
my_df
sort(my_df$rank.pop., ascending = TRUE)
sort(my_df$rank.pop., decreasing = TRUE)
?order
# 29
ind = order(my_df$rank.pop., decreasing = TRUE)
ind
my_df[ind, ]
# 30
str(na_example)
# 30
ind = is.na(na_example)
ind
na_example(ind)
sum(ind)
# 31
mean(na_example[!is.na(na_example)])
city_temps$f = (5/9)*(city_temps$temperature - 32)
city_temps
# 32
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro",
"San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
city_temps$c = (5/9)*(city_temps$temperature - 32)
city_temps
# 33
1/c(1, 2, 3)
# 33
1/seq(1, 100)
# 33
sum((1/seq(1, 100))^2)
pi^2
pi^2/6
str(murders)
# 34
murders$murder_rate = (murders$total / murders$population)*100000
murders$murder_rate
mean(murders$murder_rate)
# 35
low = murder_rate < 1
# 35
low = murders$murder_rate < 1
low
# 36
which(murders$murder_rate[low])
low
which(lo)
which(low)
# 37
murders$state[low]
View(murder)
View(murders)
# 38
murders$state[murders$region == "Northeast" & low]
# 39
sum(murders$murder_rate < mean(murders$murder_rate))
# 40
ind = match(c("AK", "MI", "IA"), murders$abb)
ind
murders$state[ind]
# 41
which(c("MA", "ME", "MI", "MO", "MU") %in% murders$abb)
# 42
which(c("MA", "ME", "MI", "MO", "MU") %!in% murders$abb)
# 42
which(!(c("MA", "ME", "MI", "MO", "MU") %in% murders$abb))
# 43
population_in_millions <- murders$population/10^6
total_gun_murders <- murders$total
plot(population_in_millions, total_gun_murders)
plot(population_in_millions, log10(total_gun_murders))
plot(log10(population_in_millions), log10(total_gun_murders))
# 44
histogram(murders$population)
# 44
hist(murders$population)
# 45
boxplot(murders$population, by = murders$region)
# 45
boxplot(population ~ region, data = murders)
search()
x <- c(1,2,-3,4)
if(all(x>0)){
print("All Postives")
} else{
print("Not all positives")
}
# 3
nchar = murders[nchar(murders$state) > 8, "abb"]
rm nchar
rm(list = "rm")
rm(list = "nchar")
# 3
new_names = murders[nchar(murders$state) > 8, "abb"]
new_names
# 4
sum_n = function(n){
return(sum(1:n))
}
sum_n(4)
# 4
sum_n = function(n){
return(sum(1:n))
}
sum_n(1000)
# 5
altman_plot = function(x, y){
plot(sum(x, y), y-x)
}
altman_plot(1, 2)
x <- 3
my_func <- function(y){
x <- 5
y+5
}
x
seq(1, n)
1/seq(1, n)
# 7
compute_s_n = function(n){
return(sum((1/seq(1, n))^2))
}
compute_s_n(10)
# 8
s_n = vector("numeric", 25)
s_n\
s_n
# 8
s_n = vector("numeric", 25)
for(i in 1:25){
s_n[i] = compute_s_n(i)
}
s_n
plot(s_n)
# 9
s_n = sapply(1:25, compute_s_n)
s_n
map_dbl(1:25, compute_s_n)
??map_dbl
# 10
library(purrr)
?map_dbl
map_dbl(1:25, compute_s_n)
s_n = map_dbl(1:25, compute_s_n)
# 11
plot(1:25, s_n)
# 12
sum(s_n)
s_n(5)
s_n(25)
# 12
identical(compute_s_n(25) == 25*(25+1)*(2*25+1))/6
# 12
compute_s_n(25) == (25*(25+1)*(2*25+1))/6
compute_s_n(25)
(25*(25+1)*(2*25+1))/6
# 7
compute_s_n = function(n){
return(sum((seq(1, n))^2))
}
compute_s_n(10)
# 8
s_n = vector("numeric", 25)
for(i in 1:25){
s_n[i] = compute_s_n(i)
}
# 9
s_n = sapply(1:25, compute_s_n)
# 10
library(purrr)
s_n = map_dbl(1:25, compute_s_n)
# 11
plot(1:25, s_n)
# 12
compute_s_n(25) == (25*(25+1)*(2*25+1))/6
